!--------------------------------------------------------------------------
! This is free software, you can use/redistribute/modify it under the terms of
! the EC-RPN License v2 or any later version found (if not provided) at:
! - http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
! - EC-RPN License, 2121 TransCanada, suite 500, Dorval (Qc), CANADA, H9P 1J3
! - service.rpn@ec.gc.ca
! It is distributed WITHOUT ANY WARRANTY of FITNESS FOR ANY PARTICULAR PURPOSE.
!-------------------------------------------------------------------------- 

!/**
module phys_itf_mod
   use hgrid_wb
   use config_mod
   use cmcdate_mod
   use bus_fold_mod
   use ptr_store
   use statfld_dm_mod
   use phy_output_mod, only: phy_output0, phy_output1
   use phys_prestep_mod
   implicit none
   private
   !@objective Interface to RPNPhy
   !@author Stephane Chamberland, 2012-02
   !@revisions
   !  2013-06 S.Chamberland: adapt to rpnphy 5.5 API
   !  2014-04 S.Chamberland: adapt to rpnphy 5.6 API
   !@public_functions
   public :: phys_config,phys_init,phys_input,phys_step,phys_output,phys_blocstats
   !@public_params
   !@public_vars
!**/
#include <arch_specific.hf>
#include <rmnlib_basics.hf>
#include <clib_interface.cdk>
#include <WhiteBoard.hf>
#include <gmm.hf>
#include <msg.h>
   include "phy_itf.inc"

   character(len=3),parameter :: OPT_GET = 'GET'
   character(len=3),parameter :: OPT_SET = 'SET'
   integer,parameter :: COMPATIBILITY_LVL = 4
   integer,parameter :: MAX_LEVELS = 1024
   integer,parameter :: IGRID_YIN = 0
   integer,parameter :: IGRID_YANG = 1
   integer,parameter :: OFFLINE_TRUE(1) = (/1/)

   logical,save :: m_init_L = .false. ,&
        m_init2_L = .false., &
        m_isphy_L = .false.
   integer,save :: m_msgUnit = RMN_ERR
   logical,save :: m_print_L = .false.

   integer,save :: p_ni,p_nj,p_nk,p_bent_top,p_bdyn_top,p_bper_top,p_bvol_top

   interface phys_output
      module procedure phy_output0
      module procedure phy_output1
   end interface

contains

   !/**
   function phys_config(F_cfg_basename_S) result(F_istat)
      implicit none
      !@objective Read phy nml
      !@arguments
      character(len=*),intent(in) :: F_cfg_basename_S  !- Name of the config file [w/o extension]
      !@return
      integer :: F_istat
      !@author Stephane Chamberland, 2012-02
      !@revisions
   !**/
      character(len=*),parameter :: NML_S = "physics_cfgs"
      logical,external :: set_dcst !call back to set constants
      integer,external :: msg_getUnit,phy_nml,phy_compatibility
      character(len=RMN_PATH_LEN) :: path_nml_S
      character(len=MSG_MAXLEN) :: msg_S
      integer :: istat,phycompa
      !---------------------------------------------------------------------
      call msg(MSG_DEBUG,'[BEGIN] phys_config')
      F_istat = RMN_OK
      if (m_init_L) return
      m_init_L = .true.
      F_istat = RMN_ERR

      m_msgUnit = msg_getUnit(MSG_INFO)
      m_print_L = (m_msgUnit >= 0)

      phycompa = phy_compatibility()
      if (phycompa /= COMPATIBILITY_LVL) then
         write(msg_S,'(a,i2,a,i2)') &
              '(phys) InCompatible Physic Interface; Need  level=',&
              COMPATIBILITY_LVL,'; Found physic Compat level=',phycompa
         call msg(MSG_INFO,msg_S)
         return
      endif
      write(msg_S,'(a,i2,a)') '(phys) Compatibility level is OK: (level=',phycompa,')'
      call msg(MSG_INFO,msg_S)

      istat = config_path(path_nml_S,F_cfg_basename_S)
      istat = clib_isfile(trim(path_nml_S))
      if (.not.RMN_IS_OK(istat)) then
         call msg(MSG_WARNING,'(phys) Config file not found: '//trim(path_nml_S))
      else
         call msg(MSG_INFO,'(phys) Reading Config: '//trim(path_nml_S)//'::'//trim(NML_S))
         F_istat = phy_nml(path_nml_S,set_dcst,m_isphy_L,m_msgUnit)
      endif

      if (RMN_IS_OK(F_istat)) then
         call phy_com('OFFLINE',OFFLINE_TRUE,1,OPT_SET)

         if(m_msgUnit.ge.0) then
            write(m_msgUnit,2000)
2000        format( &
                '                                                     ', &
              / ' ****************************************************', &
              / ' ****************************************************', &
              / '                                                     ', &
              / '    UPDATED PHYSICS_CFGS NAMELIST FOR SPS :          ', &
              / '    ---------------------                            ', &
              / '                                                     ')
            write(m_msgUnit,2001)
2001        format( &
                '       FLUVERT = SURFACE                             ', &
              / '       AGREGAT = .TRUE.                              ', &
              / '       BKGALB  = .FALSE.                             ', &
              / '       ICEMELT = .TRUE.                              ', &
              / '                                                     ')
         endif

         call msg(MSG_INFO,'(phys) Config OK')
      else
         call msg(MSG_INFO,'(phys) Config reading problem')
      endif
      call msg(MSG_DEBUG,'[END] phys_config')
      !---------------------------------------------------------------------
      return
   end function phys_config


   !/**
   function phys_init(F_dateo_S,F_dt_8,F_step) result(F_istat)
      implicit none
      !@objective 
      !@arguments
      character(len=*),intent(in) :: F_dateo_S
      real(RDOUBLE),intent(in) :: F_dt_8
      integer,intent(in) :: F_step
      !@return
      integer :: F_istat
      !@author Stephane Chamberland, 2012-02
      !@revisions
   !**/
      external :: itf_phy_getijlalo,itf_phy_rdfile2
      integer,external :: phy_init3
      integer,parameter :: NK_MIN = 3
      integer :: err(12),idateo,Schm_Tlift,grid_id,l_i0,l_j0,istat,p_nk,Tlift,surf_idx
      real :: std_p_prof(MAX_LEVELS)
      real(RDOUBLE) :: Lvl_ptop_8
      logical :: Lvl_stag_L,Lvl_NotopThL_L,Lvl_Tlift_L
      character(len=128) :: msg_S
      !---------------------------------------------------------------------
      call msg(MSG_DEBUG,'[BEGIN] phys_init')
      F_istat = RMN_ERR
      if (.not.m_init_L) return

      F_istat = RMN_OK
      if (m_init2_L) return
      m_init2_L = .true.
      if (.not.m_isphy_L) then
         call msg(MSG_INFO,'(phys) Initialisation OK, Nothing done, no Physic')
         return
      endif

      call datp2f(idateo,F_dateo_S)
      err(:) = RMN_OK
      err(1) = wb_get('levels_cfgs/surf_idx',surf_idx)
      err(2) = wb_get('levels_cfgs/stag_L',Lvl_stag_L)
      err(3) = wb_get('levels_cfgs/Lvl_ptop_8',Lvl_ptop_8)
!!$      err(4) = wb_get('levels_cfgs/Lvl_NoTopThL_L',Lvl_NotopThL_L)
      Lvl_NotopThL_L = .false. !TODO: is this needed?
      err(5) = wb_get('levels_cfgs/Lvl_Tlift_L',Lvl_Tlift_L)
      err(6) = wb_get('std_p_prof_m',std_p_prof,p_nk)
      if (p_nk < NK_MIN) then
         F_istat = RMN_ERR
         write(msg_S,'(a,i4,a,i2)') "(phys_init) Not enough levels, nk=",p_nk," <",NK_MIN
         call msg(MSG_ERROR,msg_S)
         return
      endif
!!$     if (.not.Lvl_NotopThL_L) then
!!$         std_p_prof(1) = sngl(Lvl_ptop_8) !TODO: check this
!!$      endif
      !TODO-later:  if (surf_idx /= p_nk) err(7) = RMN_ERR 
      !TODO: define koff relative to dyn var
      err(7) = hgrid_wb_get('localz',grid_id,l_i0,l_j0,p_ni,p_nj)
      if (.not.RMN_IS_OK(err(7))) then
         F_istat = RMN_ERR
         call msg(MSG_ERROR,'(phys_init) Probleme getting grid dims')
         return
      endif

      call phy_optl('VSTAG',Lvl_stag_L,1,OPT_SET,m_print_L,err(8))
      call phy_opti('TLIFT',Lvl_Tlift_L,1,OPT_SET,m_print_L,err(9))
      call phy_optl('NOTOP',Lvl_NotopThL_L,1,OPT_SET,m_print_L,err(10))

      err(10) = wb_put('itf_phy/READ_TRACERS_NTR', 0)
      err(11) = wb_put('itf_phy/PHY_OFFSET', 0)
      !TODO-later: std_p_prof should be passed as an arg to phy_init
      err(12) = phy_init3(idateo,real(F_dt_8),l_i0,l_i0-1+p_ni,l_j0,l_j0-1+p_nj,p_nk,itf_phy_getijlalo,itf_phy_rdfile2)
      if (.not.RMN_IS_OK(err(12))) &
           call msg(MSG_ERROR,'(phys_init) Probleme in phy_init')
      
      call phy_com_r('STD_P_PROF',std_p_prof(1:p_nk),p_nk,OPT_SET)

      !TODO-later: if MOYHR needed for offline mode?
!!$      call phy_opti('MOYHR' ,P_out_moyhr,1, OPT_GET,m_print_L,err(8))
!!$!     Re-define P_out_moyhr in units of hours, rather than in timesteps
!!$      P_out_moyhr = ( P_out_moyhr * Cstv_dt_8 ) / 3600.

      F_istat = minval(err(:))
      if (RMN_IS_OK(F_istat)) then
         call msg(MSG_INFO,'(phys) Initialisation OK')
      else
         call msg(MSG_ERROR,'(phys) Problem in Initialisation')
      endif
      call msg(MSG_DEBUG,'[END] phys_init')
      !---------------------------------------------------------------------
      return
   end function phys_init


   !/**
   function phys_input(F_step) result(F_istat)
      implicit none
      !@objective 
      !@arguments
      integer,intent(in) :: F_step
      !@return
      integer :: F_istat
      !@author Stephane Chamberland, 2012-02
      !@revisions
   !**/
      integer, external :: itf_prefold_opr,phy_gmm2phy2
      character(len=*),parameter :: INPUT_TABLE = 'physics_input_table'
      logical,save :: is_init_L = .false.
      integer,save :: dateo = 0, phy_grid_id = -1
      real(RDOUBLE),save :: dt_8
      character(len=RMN_PATH_LEN),save :: &
           geofilename_S = 'GEOPHY/Gem_geophy.fst',&
           config_S = '',&
           input_dir_S = ''
      character(len=RMN_PATH_LEN) :: config_dir0_S,pwd_S,dateo_S,msg_S
      integer :: istat,G_ngrids,G_igrid
      !---------------------------------------------------------------------
      call msg(MSG_DEBUG,'[BEGIN] phys_input')
      F_istat = RMN_ERR
      if (.not.m_init2_L) return

      F_istat = RMN_OK
      write(msg_S,'(a,I5.5)') '(phys) Input Step=',F_step
      if (.not.m_isphy_L) then
         call msg(MSG_INFO,trim(msg_S)//' OK, Nothing done, no Physic')
         return
      endif
      call msg(MSG_INFO,trim(msg_S)//' Begin')

      IF_INIT: if (.not.is_init_L) then
         is_init_L = .true.
         F_istat = min(hgrid_wb_get('localz',phy_grid_id),F_istat)
         F_istat = min(wb_get('path/input',input_dir_S),F_istat)
         F_istat = min(wb_get('path/config_dir0',config_dir0_S),F_istat)
         F_istat = min(config_cp2localdir(INPUT_TABLE,config_dir0_S),F_istat)
         F_istat = min(clib_getcwd(pwd_S),F_istat)
         config_S = trim(pwd_S)//'/'//INPUT_TABLE
         F_istat = min(wb_get('time_cfgs/step_runstrt_S',dateo_S),F_istat)
         F_istat = min(wb_get('time_cfgs/step_dt',dt_8),F_istat)
         dateo = cmcdate_fromprint(dateo_S)
         istat = wb_get('ptopo/ngrids',G_ngrids)
         istat = min(wb_get('ptopo/igrid',G_igrid),istat)
         if (.not.RMN_IS_OK(F_istat)) then
            G_ngrids = 1
            G_igrid  = 0
         endif
         if (G_ngrids > 1) then
            input_dir_S = trim(input_dir_S)//'/..'
!!$            if (G_igrid == IGRID_YANG) then
!!$               geofilename_S = 'GEOPHY/Gem_geophy_YAN.fst'
!!$            else
!!$               geofilename_S = 'GEOPHY/Gem_geophy_YIN.fst'
!!$            endif
         endif
         F_istat = min(phy_geom2phy(itf_prefold_opr,nint(dt_8),phy_grid_id),F_istat)
      endif IF_INIT
      call collect_error(F_istat)
      if (.not.RMN_IS_OK(F_istat)) then
         call msg(MSG_ERROR,trim(msg_S)//' End with Problems in Init')
         return
      endif

      F_istat = min(phy_gmm2phy2(),F_istat)
      F_istat = phy_input2(itf_prefold_opr,dateo, &
                             nint(dt_8),F_step,phy_grid_id,phy_grid_id, &
                             config_S,input_dir_S,geofilename_S)
!!$      F_istat = min(phy_gmm2phy(itf_prefold_opr,dateo, nint(dt_8), &
!!$                            F_step,phy_grid_id),F_istat)

      call collect_error(F_istat)
      if (RMN_IS_OK(F_istat)) then
         call msg(MSG_INFO,trim(msg_S)//' End OK')
      else
         call msg(MSG_ERROR,trim(msg_S)//' End with Problems')
      endif
      call msg(MSG_DEBUG,'[END] phys_input')
      !---------------------------------------------------------------------
      return
   end function phys_input


   !/**
   function phys_step(F_step) result(F_istat)
      implicit none
      !@objective 
      !@arguments
      integer,intent(in) :: F_step
      !@return
      integer :: F_istat
      !@author Stephane Chamberland, 2012-02
      !@revisions
   !**/
      integer, external :: phy_step2
      character(len=MSG_MAXLEN) :: msg_S
      !---------------------------------------------------------------------
      call msg(MSG_DEBUG,'[BEGIN] phys_step')
      F_istat = RMN_ERR
      if (.not.m_init2_L) return

      F_istat = RMN_OK
      write(msg_S,'(a,I5.5)') '(phys) Step=',F_step
      if (.not.m_isphy_L) then
         call msg(MSG_INFO,trim(msg_S)//' OK, Nothing done, no Physic')
         return
      endif

      call msg(MSG_INFO,trim(msg_S)//' Begin')

      F_istat = phys_prestep(F_step)

      F_istat = min(phy_step2(F_step,F_step),F_istat)

      call collect_error(F_istat)
      if (RMN_IS_OK(F_istat)) then
         call msg(MSG_INFO,trim(msg_S)//' End OK')
      else
         call msg(MSG_ERROR,trim(msg_S)//' End with Problems')
      endif
      call msg(MSG_DEBUG,'[END] phys_step')
      !---------------------------------------------------------------------
      return
   end function phys_step


   !/**
   subroutine phys_blocstats(F_step,F_by_levels_L)
      implicit none
      !@objective Stub
      !@arguments
      integer,intent(in) :: F_step
      logical,intent(in) :: F_by_levels_L
   !**/
      character(len=*),parameter :: HGRID_S = 'local#'
      integer,parameter :: STAT_PERCISION = 4
      integer,parameter :: NSTATMAX = 64
      integer,parameter :: MAX_PARAMS = 8
      integer,parameter :: BUSPAR_NIK=2
      integer,parameter :: STAT_NK_MAX = 2
      character(len=32),save :: stat_list_S(NSTATMAX)
      integer,save :: l_ijk(3) = (/0,0,0/)
      integer,save :: u_ijk(3) = (/0,0,0/)
      integer,save :: nstat = 0, p_ni = 0, p_nk = 0
      logical,save :: init_L = .false.
      character(len=4)   :: outname_S,inname_S,bus_S
      character(len=MSG_MAXLEN) :: msg_S,vgrid_S,varname_S,name2_S
      real,pointer :: data3dr4(:,:,:)
      integer :: istat,ivar,grid_id,gi0,gj0,lni,lnj,hx,hy,busidx,params(MAX_PARAMS),k0,kn,k
      !---------------------------------------------------------------------
      IF_INIT: if (.not.init_L) then
         istat = wb_get('sps_cfgs/stat_list_s',stat_list_S,nstat)
         istat = hgrid_wb_get(HGRID_S,grid_id,gi0,gj0,lni,lnj,hx,hy)
         call phy_opti('NI',p_ni,1,OPT_GET,.false.,istat)
         call phy_opti('NK',p_nk,1,OPT_GET,.false.,istat)
         if (.not.RMN_IS_OK(istat)) then
            call msg(MSG_ERROR,'(phys_blocstats) Problem getting grid info')
            nstat = 0
         else
            l_ijk(1:2) = (/1-hx,1-hy/) ; l_ijk(3) = 1
            u_ijk(1:2) = (/lni+hx,lnj+hy/) ; u_ijk(3) = 1
         endif
         init_L = .true.
      endif IF_INIT

      if (nstat <= 0) return

      write(msg_S,'(a,I5.5)') '---- (phys) Blocstat Step=',F_step
      call msg(MSG_INFO,trim(msg_S)//' [Begin] ------------')
      
      VARLOOP: do ivar=1,nstat
         if (stat_list_S(ivar) == '') cycle
         busidx = -1
         varname_S = stat_list_S(ivar)
         outname_S = ' '
         inname_S = '  '
         bus_S = ' '
         istat = phy_getindx3(varname_S,outname_S,inname_S,bus_S,busidx,params,MAX_PARAMS)
         if (busidx <= 0 .or. .not.RMN_IS_OK(istat)) then
            call msg(MSG_INFOPLUS,'(phys_blocstats) Skipping var (not in bus): '//trim(stat_list_S(ivar))//')')
            cycle VARLOOP
         endif
         if (params(BUSPAR_NIK) == p_ni) then
            kn = 1
         else
            kn = params(BUSPAR_NIK) / p_ni
         endif
         u_ijk(3) = kn
         nullify(data3dr4)
         call ptr_store_get(data3dr4,l_ijk,u_ijk)
         if (.not.associated(data3dr4)) then
            call msg(MSG_INFOPLUS,'(phys_blocstats) Problem getting workspace for: '//trim(stat_list_S(ivar)))
            cycle VARLOOP
         endif
         k0 = 1
         istat = bus_unfold(data3dr4,trim(bus_S)//'d',busidx,k0,kn)
         if (.not.RMN_IS_OK(istat)) then
            call msg(MSG_INFOPLUS,'(phys_blocstats) Problem getting values from bus for: '//trim(stat_list_S(ivar)))
            cycle VARLOOP
         endif
         k0 = max(k0,kn-STAT_NK_MAX+1)
         if (F_by_levels_L) then
            do k=k0,kn
               write(name2_S,'(a,i3.3,a)') trim(stat_list_S(ivar))//'(',k,')'
               call statfld_dm(data3dr4(:,:,k),name2_S,F_step,'phy_blocstats',STAT_PERCISION) 
            enddo
         else
            call statfld_dm(data3dr4(:,:,k0:kn),stat_list_S(ivar),F_step,'phy_blocstats',STAT_PERCISION) 
         endif
      enddo VARLOOP

      call msg(MSG_INFO,trim(msg_S)//' [End]   ------------')
      !---------------------------------------------------------------------
      return
   end subroutine phys_blocstats

end module phys_itf_mod

